#1.3 akka streams 背后的设计原则（Desgin Principles behind Akka Streams）
花了相当长的一段时间，直到我们对API的外观和风格以及架构的实施相当满意，同时，凭借直觉引导设计是非常有探索性的研究。这一部分详细的介绍了调查结果，并将在过程呈现的一套原则编纂下来了。

---
|注意，经过详细的介绍请记住，在akka stream的API中和只是描述在个别处理阶段数据传递的实现细节的Reactive stream接口是完全解耦的，
---

这意味着我们提供所有必要的工具来表达任何流处理拓扑中,我们所有的模型
这一领域的重要方面(背压、缓冲、转换、故障恢复等)
无论用户构建可重用在一个更大的上下文中。
Akka流不发送下降流元素死信办公室
提供的一个重要后果只能依赖特性的限制Akka流
不能确保所有对象发送通过处理拓扑处理。元素可以被删除
原因有很多:
•普通用户代码可以使用一个元素的映射(…)阶段和产生一个完全不同的一个作为
结果
•共同故意下降流操作符元素,例如带/降/过滤器/合并/缓冲。

##1.3.1 用户对akka stram报以怎样的期待（ What shall users of Akka Streams expect?）
akka是建立在有意识的决定提供最小的，一致的而不是简单的或者直观的API上的。该信条是，我们倾向与明确而非魔法，如果我们提供了一个功能，那它必须始终能毫无例外的工作。另一种说法是我们最大限度的降低规则数量而不是试图和我们认为用户期望的规则保持接近。由此得出akka stream实现的原则是：
* 所有的功能都是明确的，没有魔法的
* 最高组合性，组件每一部分的功能都得以保留
* 详尽领域模型的分布式流处理
这意味着我们提供完善的工具来描述任何流处理拓扑中，我们模拟无论用户是否在一个更大的上下文中构建可重用，所有这个领域必要的方面（`back-pressure`、缓存、转化、故障恢复等）。
• stream failure will tear down the stream without waiting for processing to finish, all elements that are in
flight will be discarded
• stream cancellation will propagate upstream (e.g. from a take operator) leading to upstream processing steps
being terminated without having processed all of their inputs
###akka stream 不能发送废弃流的元素到死信办公室
akka stream不能确保所有通过处理拓扑的对象都会被处理的限制造成只提供可以依赖的功能的结果。很多原因造成了元素可以被删除：
* 普通的用户代码可以在`map(...)`阶段消耗一个元素，并且产生一个完全不同的元素作为结果
* commo流操作者有意的丢弃元素，如采取take/drop/filter/conflate/buffer/...
* 流故障将会摧毁流而不必等到进程结束，所有其中的元素都将会被丢弃
* 流取消将被传递到上游，(如take操作者)，导致上游处理步骤被终止而不必等待所有的输入被处理
这意味着需要被清理的的那些发送到流的jvm对象的情况需要用户确信发生在akka stream的设备之外。
###产生实现约束
组合性需要局部流拓扑的可重用性，导致我们取消描述流作为(部分)图，可以作为复合sources、flows(又名管道)和sinks数据的方法。这些构建块应该自由共享，它们具备自由组合，形成更大的图的能力。为了启动流处理，这些零件的表现因此必须是那些以显式介入物化的不可变的蓝图。由此产生的由蓝图所规定的固定拓扑结构的流处理引擎也是不可变的。动态网络需要使用Reactive stream接口接入不同的引擎来显式的建模。进程物化通常会创建在与进程引擎运行时互作用时有用的特定对象，例如关闭或者提取指标。这意味着物化函数产生了一个叫做图的物化值。